comment ~
--------------------------
ВЫХОД-5

Задача_1 

Написать программу из двух модулей. 
В головном модуле описать двойное слово  X (содержимое которого трактуется 
как число без знака) и байт Res (содержимое которого трактуется как число 
со знаком).  
Во вспомогательном  модуле описать  общедоступную процедуру Power2(X,Res) 
со стандартными соглашениями о связях  (stdcall).  Параметр  X передаётся 
в процедуру по значению, Res – по ссылке.  Процедура Power2 выполняет 
проверку 32-битной беззнаковой величины Х: является ли она степенью двойки, 
т.е. существует ли такое  k: от 0 до 31, что X=2^k. Если да, то процедура 
записывает в байт Res показатель k найденной степени двойки, иначе – записывает
в байт Res -1 (минус!). В процессе своей работы процедура не использует команды
умножения и деления. 
Головной модуль вводит значение переменной Х,  после чего обращается к внешней 
процедуре Power2(X,Res)  для проверки числа X.  Затем головной модуль выводит 
в окно консоли полученный в Res ответ. На этом работа двухмодульной программы 
завершается.

Подсказка: в двоичном представлении степень двойки выглядит как 000…010…00, 
начальная или конечная последовательность нулей может отсутствовать.  При 
проверке числа Х рекомендуется использовать маску вида 000…010…00 с подвижной 
единицей (передвигающейся от правого края маски до левого края), а также 
команду xor для сравнения битового представления числа Х  с данной маской 
(командами cmp и sub для сравнения с маской - не пользоваться!).  
Тесты:   
1  -> 0,       2  -> 1,      5  -> -1,      256  -> 8,     65536  -> 16,      
65535  > -1,    1048576  > 20,   2147483648   > 31,     4000000000  > -1   

--------------------------
ВСПОМОГАТЕЛЬНЫЙ МОДУЛЬ
--------------------------
~
; эти две строчки вместо include console.inc (не трогайте их !!!):

.686
.model flat,stdcall

; далее - ваше решение

public Power2

.code
Power2 proc
    push EBP
    mov EBP, ESP
    push EAX
    push EBX
    push ECX
    push EDX
    mov EAX, [EBP + 8];X
    mov ECX, 32
    mov EBX, 1
@L: mov EDX, EAX
    xor EDX, EBX
    test EDX, 0FFFFFFFFh
    jZ @good
    ROL EBX, 1
    loop @L
    mov EAX, [EBP + 12]
    mov [EAX], byte ptr -1
    jmp @ennd
@good:
    mov EAX, [EBP + 12]
    mov EBX, 32
    sub EBX, ECX
    mov [EAX], EBX
@ennd:
    pop EDX
    pop ECX
    pop EBX
    pop EAX
    pop EBP
    ret 4 * 2
Power2 endp

end
    
    